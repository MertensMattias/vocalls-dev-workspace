/**
 * Build Command - Creates monolithic Vocalls-compatible output
 * 
 * Follows Vocalls loading order:
 * 1. globalCode.js
 * 2. globalVariables.js  
 * 3. globalLibraries/active/* (in dependency order)
 * 4. callScripts/main.js
 */

import { promises as fs } from 'fs';
import { join, resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { findWorkspaceRoot, findProject, log, error } from '../utils/workspace.js';
import { validateES51Compliance } from '../utils/validation.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export async function buildProject(projectName, options = {}) {
  try {
    const workspaceRoot = await findWorkspaceRoot();
    const projectPath = await findProject(projectName);
    
    log(`ðŸ”¨ Building project: ${projectName}`);
    
    if (options.clean) {
      await cleanBuildDirectory(projectPath);
    }
    
    const config = await loadProjectConfig(projectPath);
    const builder = new VocallsProjectBuilder(projectPath, config, options);
    
    const result = await builder.build();
    
    log(`âœ… Build completed successfully!`);
    log(`   Monolith: ${result.monolithPath}`);
    log(`   Size: ${Math.round(result.size / 1024)}KB`);
    log(`   Files processed: ${result.filesProcessed}`);
    
    return result;
    
  } catch (err) {
    error(`Build failed: ${err.message}`);
    throw err;
  }
}

class VocallsProjectBuilder {
  constructor(projectPath, config, options = {}) {
    this.projectPath = projectPath;
    this.config = config;
    this.options = options;
    this.sections = [];
    this.filesProcessed = 0;
  }
  
  async build() {
    // Create build directory
    const buildDir = join(this.projectPath, 'dist');
    await fs.mkdir(buildDir, { recursive: true });
    
    // Process files in Vocalls loading order
    await this.processGlobalCode();
    await this.processGlobalVariables();
    await this.processGlobalLibraries();
    await this.processMainScript();
    
    // Generate monolithic output
    const monolith = this.generateMonolith();
    
    // Validate ES5.1 compliance
    if (this.options.prod) {
      await this.validateCompliance(monolith);
    }
    
    // Write output
    const monolithPath = join(buildDir, `${this.config.name}.monolith.js`);
    await fs.writeFile(monolithPath, monolith, 'utf8');
    
    return {
      monolithPath,
      size: Buffer.byteLength(monolith, 'utf8'),
      filesProcessed: this.filesProcessed
    };
  }
  
  async processGlobalCode() {
    const globalCodePath = join(this.projectPath, 'src', 'globalCode.js');
    if (await this.fileExists(globalCodePath)) {
      const content = await fs.readFile(globalCodePath, 'utf8');
      this.addSection('Global Code', content, globalCodePath);
    }
  }
  
  async processGlobalVariables() {
    const globalVarsPath = join(this.projectPath, 'src', 'globalVariables.js');
    if (await this.fileExists(globalVarsPath)) {
      const content = await fs.readFile(globalVarsPath, 'utf8');
      this.addSection('Global Variables', content, globalVarsPath);
    }
  }
  
  async processGlobalLibraries() {
    const libsDir = join(this.projectPath, 'src', 'globalLibraries', 'active');
    
    if (await this.fileExists(libsDir)) {
      // Get dependency order from config or use alphabetical
      const files = this.config.libraryOrder || await this.getLibraryFiles(libsDir);
      
      for (const file of files) {
        const filePath = join(libsDir, file);
        if (await this.fileExists(filePath)) {
          const content = await fs.readFile(filePath, 'utf8');
          this.addSection(`Library: ${file}`, content, filePath);
        }
      }
    }
  }
  
  async processMainScript() {
    const scriptPath = join(this.projectPath, 'src', 'callScripts', 'main.js');
    if (await this.fileExists(scriptPath)) {
      const content = await fs.readFile(scriptPath, 'utf8');
      this.addSection('Main Script', content, scriptPath);
    } else {
      throw new Error('Main script not found: src/callScripts/main.js');
    }
  }
  
  generateMonolith() {
    const header = this.generateHeader();
    const body = this.sections.map(section => section.content).join('\\n\\n');
    
    return `${header}\\n\\n${body}`;
  }
  
  generateHeader() {
    const timestamp = new Date().toISOString();
    return `// ========================================
// VOCALLS COMPATIBLE MONOLITHIC IVR
// Project: ${this.config.name}
// Customer: ${this.config.customer || 'Unknown'}
// Built: ${timestamp}
// Target: Vocalls ES5.1 Runtime
// Files: ${this.filesProcessed}
// ========================================

/* 
 * This file was automatically generated by the Vocalls Development Environment
 * It contains all dependencies in the correct order for the Vocalls runtime
 * 
 * Available globals in Vocalls runtime:
 * - context.callInfo, context.session.variables
 * - jsonHttpRequest, httpRequest, Storage
 * - logInfo, logWarn, logError, log_debug
 * - nowUTC and other utility functions
 */`;
  }
  
  addSection(name, content, filePath) {
    const cleanContent = this.cleanContent(content);
    const sectionHeader = `// ========================================\\n// ${name}\\n// Source: ${filePath}\\n// ========================================`;
    
    this.sections.push({
      name,
      content: `${sectionHeader}\\n${cleanContent}`,
      filePath
    });
    
    this.filesProcessed++;
    log(`  ðŸ“ ${name}`);
  }
  
  cleanContent(content) {
    // Remove excessive comments and whitespace for production builds
    if (this.options.prod) {
      return content
        .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // Remove block comments
        .replace(/\\/\\/.*$/gm, '') // Remove line comments
        .replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n') // Reduce multiple empty lines
        .trim();
    }
    return content.trim();
  }
  
  async validateCompliance(content) {
    const violations = validateES51Compliance(content);
    
    if (violations.length > 0) {
      error(`\\nâŒ ES5.1 compliance violations found:`);
      violations.slice(0, 10).forEach(v => {
        error(`   Line ${v.line}: ${v.message}`);
        error(`   Code: ${v.snippet}`);
      });
      
      if (violations.length > 10) {
        error(`   ... and ${violations.length - 10} more violations`);
      }
      
      throw new Error('Build failed due to compliance violations');
    }
    
    log(`âœ… ES5.1 compliance validated`);
  }
  
  async getLibraryFiles(libsDir) {
    const files = await fs.readdir(libsDir);
    return files
      .filter(file => file.endsWith('.js'))
      .sort(); // Alphabetical order as fallback
  }
  
  async fileExists(path) {
    try {
      await fs.access(path);
      return true;
    } catch {
      return false;
    }
  }
}

async function loadProjectConfig(projectPath) {
  const configPath = join(projectPath, 'project.json');
  
  try {
    const content = await fs.readFile(configPath, 'utf8');
    return JSON.parse(content);
  } catch (err) {
    // Return default config if file doesn't exist
    return {
      name: projectPath.split(/[\\\\/]/).pop(),
      customer: 'Unknown',
      libraryOrder: []
    };
  }
}

async function cleanBuildDirectory(projectPath) {
  const buildDir = join(projectPath, 'dist');
  
  try {
    await fs.rm(buildDir, { recursive: true, force: true });
    log(`ðŸ§¹ Cleaned build directory`);
  } catch (err) {
    // Ignore if directory doesn't exist
  }
}